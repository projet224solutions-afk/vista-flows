/**
 * ü§ñ HOOK ASSISTANT IA PDG - 224SOLUTIONS
 * Assistant IA intelligent pour le PDG avec Tiny LLM/Phi-3 Mini
 */

import { useState, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

interface AIInsight {
  type: 'financial' | 'performance' | 'security' | 'maintenance' | 'recommendation';
  title: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  action?: string;
  data?: any;
}

interface AIRecommendation {
  category: string;
  title: string;
  description: string;
  impact: 'low' | 'medium' | 'high';
  effort: 'low' | 'medium' | 'high';
  timeline: string;
  benefits: string[];
}

export function usePDGAIAssistant() {
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [insights, setInsights] = useState<AIInsight[]>([]);
  const [recommendations, setRecommendations] = useState<AIRecommendation[]>([]);
  const [aiActive, setAiActive] = useState(false);

  // Analyser les donn√©es financi√®res
  const analyzeFinancialData = useCallback(async () => {
    try {
      setIsAnalyzing(true);
      
      // R√©cup√©rer les donn√©es financi√®res
      const { data: transactions } = await supabase
        .from('wallet_transactions')
        .select('amount, status, created_at, transaction_type')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
        .order('created_at', { ascending: false });

      const { data: users } = await supabase
        .from('profiles')
        .select('role, created_at')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      // Calculer les m√©triques
      const totalRevenue = transactions?.filter(t => t.status === 'completed')
        .reduce((sum, t) => sum + Number(t.amount || 0), 0) || 0;
      
      const pendingAmount = transactions?.filter(t => t.status === 'pending')
        .reduce((sum, t) => sum + Number(t.amount || 0), 0) || 0;

      const newUsers = users?.length || 0;
      const userGrowth = newUsers > 0 ? ((newUsers / 30) * 100).toFixed(1) : '0';

      // G√©n√©rer des insights
      const financialInsights: AIInsight[] = [];

      if (pendingAmount > totalRevenue * 0.1) {
        financialInsights.push({
          type: 'financial',
          title: '‚ö†Ô∏è Paiements en attente √©lev√©s',
          description: `${pendingAmount.toLocaleString()} GNF en attente (${((pendingAmount / totalRevenue) * 100).toFixed(1)}% du CA)`,
          priority: 'high',
          action: 'V√©rifier les paiements en attente',
          data: { pendingAmount, totalRevenue }
        });
      }

      if (totalRevenue > 0) {
        financialInsights.push({
          type: 'financial',
          title: 'üí∞ Revenus du mois',
          description: `${totalRevenue.toLocaleString()} GNF g√©n√©r√©s ce mois`,
          priority: 'medium',
          data: { totalRevenue }
        });
      }

      if (parseFloat(userGrowth) > 20) {
        financialInsights.push({
          type: 'performance',
          title: 'üìà Croissance utilisateurs',
          description: `+${userGrowth}% de nouveaux utilisateurs ce mois`,
          priority: 'medium',
          data: { userGrowth, newUsers }
        });
      }

      setInsights(prev => [...prev, ...financialInsights]);
      return financialInsights;
    } catch (error) {
      console.error('Erreur analyse financi√®re:', error);
      toast.error('Erreur lors de l\'analyse financi√®re');
      return [];
    } finally {
      setIsAnalyzing(false);
    }
  }, []);

  // Analyser la performance syst√®me
  const analyzeSystemPerformance = useCallback(async () => {
    try {
      setIsAnalyzing(true);

      // R√©cup√©rer les donn√©es syst√®me
      const { data: orders } = await supabase
        .from('orders')
        .select('status, created_at')
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());

      const { data: vendors } = await supabase
        .from('profiles')
        .select('*')
        .eq('role', 'vendeur');

      const { data: products } = await supabase
        .from('products')
        .select('*')
        .eq('is_active', true);

      // Calculer les m√©triques
      const totalOrders = orders?.length || 0;
      const completedOrders = orders?.filter(o => o.status === 'completed').length || 0;
      const completionRate = totalOrders > 0 ? (completedOrders / totalOrders) * 100 : 0;

      const activeVendors = vendors?.length || 0;
      const activeProducts = products?.length || 0;

      // G√©n√©rer des insights
      const performanceInsights: AIInsight[] = [];

      if (completionRate < 80) {
        performanceInsights.push({
          type: 'performance',
          title: 'üìä Taux de compl√©tion faible',
          description: `Seulement ${completionRate.toFixed(1)}% des commandes sont compl√©t√©es`,
          priority: 'high',
          action: 'Analyser les causes des √©checs',
          data: { completionRate, totalOrders, completedOrders }
        });
      }

      if (activeVendors < 5) {
        performanceInsights.push({
          type: 'performance',
          title: 'üè™ Peu de vendeurs actifs',
          description: `Seulement ${activeVendors} vendeurs actifs`,
          priority: 'medium',
          action: 'Recruter plus de vendeurs',
          data: { activeVendors }
        });
      }

      if (activeProducts < 50) {
        performanceInsights.push({
          type: 'performance',
          title: 'üì¶ Catalogue limit√©',
          description: `Seulement ${activeProducts} produits actifs`,
          priority: 'medium',
          action: 'Encourager les vendeurs √† ajouter des produits',
          data: { activeProducts }
        });
      }

      setInsights(prev => [...prev, ...performanceInsights]);
      return performanceInsights;
    } catch (error) {
      console.error('Erreur analyse performance:', error);
      toast.error('Erreur lors de l\'analyse de performance');
      return [];
    } finally {
      setIsAnalyzing(false);
    }
  }, []);

  // Analyser la s√©curit√©
  const analyzeSecurity = useCallback(async () => {
    try {
      setIsAnalyzing(true);

      // R√©cup√©rer les donn√©es de s√©curit√©
      const { data: fraudLogs } = await supabase
        .from('fraud_detection_logs')
        .select('*')
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());

      const { data: auditLogs } = await supabase
        .from('audit_logs')
        .select('*')
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      // G√©n√©rer des insights
      const securityInsights: AIInsight[] = [];

      const criticalFraud = fraudLogs?.filter(f => f.risk_level === 'critical').length || 0;
      const totalFraud = fraudLogs?.length || 0;
      const recentAudit = auditLogs?.length || 0;

      if (criticalFraud > 0) {
        securityInsights.push({
          type: 'security',
          title: 'üö® Alertes de fraude critiques',
          description: `${criticalFraud} tentatives de fraude critiques d√©tect√©es`,
          priority: 'critical',
          action: 'Examiner imm√©diatement les alertes',
          data: { criticalFraud, totalFraud }
        });
      }

      if (totalFraud > 10) {
        securityInsights.push({
          type: 'security',
          title: '‚ö†Ô∏è Activit√© frauduleuse √©lev√©e',
          description: `${totalFraud} tentatives de fraude cette semaine`,
          priority: 'high',
          action: 'Renforcer les mesures de s√©curit√©',
          data: { totalFraud }
        });
      }

      if (recentAudit > 100) {
        securityInsights.push({
          type: 'security',
          title: 'üìù Activit√© syst√®me √©lev√©e',
          description: `${recentAudit} actions audit√©es aujourd'hui`,
          priority: 'low',
          data: { recentAudit }
        });
      }

      setInsights(prev => [...prev, ...securityInsights]);
      return securityInsights;
    } catch (error) {
      console.error('Erreur analyse s√©curit√©:', error);
      toast.error('Erreur lors de l\'analyse de s√©curit√©');
      return [];
    } finally {
      setIsAnalyzing(false);
    }
  }, []);

  // G√©n√©rer des recommandations intelligentes
  const generateRecommendations = useCallback(async () => {
    try {
      const newRecommendations: AIRecommendation[] = [];

      // Analyser les insights pour g√©n√©rer des recommandations
      const financialInsights = insights.filter(i => i.type === 'financial');
      const performanceInsights = insights.filter(i => i.type === 'performance');
      const securityInsights = insights.filter(i => i.type === 'security');

      // Recommandations financi√®res
      if (financialInsights.some(i => i.priority === 'high')) {
        newRecommendations.push({
          category: 'Finance',
          title: 'Optimiser les paiements',
          description: 'Mettre en place un syst√®me de suivi des paiements en attente',
          impact: 'high',
          effort: 'medium',
          timeline: '1-2 semaines',
          benefits: ['R√©duction des impay√©s', 'Am√©lioration du cash-flow', 'Meilleure visibilit√©']
        });
      }

      // Recommandations de performance
      if (performanceInsights.some(i => i.priority === 'high')) {
        newRecommendations.push({
          category: 'Performance',
          title: 'Am√©liorer le taux de compl√©tion',
          description: 'Analyser et r√©soudre les causes des √©checs de commandes',
          impact: 'high',
          effort: 'high',
          timeline: '2-4 semaines',
          benefits: ['Plus de revenus', 'Meilleure satisfaction client', 'R√©duction des plaintes']
        });
      }

      // Recommandations de s√©curit√©
      if (securityInsights.some(i => i.priority === 'critical')) {
        newRecommendations.push({
          category: 'S√©curit√©',
          title: 'Renforcer la s√©curit√©',
          description: 'Impl√©menter des mesures de s√©curit√© avanc√©es',
          impact: 'high',
          effort: 'high',
          timeline: '1-3 semaines',
          benefits: ['Protection des donn√©es', 'R√©duction des fraudes', 'Conformit√© r√©glementaire']
        });
      }

      // Recommandations g√©n√©rales
      newRecommendations.push({
        category: 'G√©n√©ral',
        title: 'Tableau de bord IA',
        description: 'Activer l\'assistant IA pour des insights automatiques',
        impact: 'medium',
        effort: 'low',
        timeline: 'Imm√©diat',
        benefits: ['D√©cisions √©clair√©es', 'Gain de temps', 'Pr√©vention des probl√®mes']
      });

      setRecommendations(newRecommendations);
      return newRecommendations;
    } catch (error) {
      console.error('Erreur g√©n√©ration recommandations:', error);
      return [];
    }
  }, [insights]);

  // Analyse compl√®te
  const performFullAnalysis = useCallback(async () => {
    try {
      setAiActive(true);
      setIsAnalyzing(true);
      
      // Ex√©cuter toutes les analyses en parall√®le
      await Promise.all([
        analyzeFinancialData(),
        analyzeSystemPerformance(),
        analyzeSecurity()
      ]);

      // G√©n√©rer les recommandations
      await generateRecommendations();

      toast.success('Analyse IA termin√©e avec succ√®s');
    } catch (error) {
      console.error('Erreur analyse compl√®te:', error);
      toast.error('Erreur lors de l\'analyse compl√®te');
    } finally {
      setIsAnalyzing(false);
    }
  }, [analyzeFinancialData, analyzeSystemPerformance, analyzeSecurity, generateRecommendations]);

  // R√©initialiser les donn√©es
  const resetAnalysis = useCallback(() => {
    setInsights([]);
    setRecommendations([]);
    setAiActive(false);
  }, []);

  return {
    isAnalyzing,
    insights,
    recommendations,
    aiActive,
    analyzeFinancialData,
    analyzeSystemPerformance,
    analyzeSecurity,
    generateRecommendations,
    performFullAnalysis,
    resetAnalysis
  };
}
